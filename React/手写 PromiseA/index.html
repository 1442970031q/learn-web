<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>
    <script>
        // function Dog() {
        //     this.name = 'dog'
        // }
        // console.log(Dog.prototype)
        // Dog.prototype.sayHi = function () {
        //     console.log(`${this.name} Hi!!`)
        // }
        /**
         *
         * function Foo(){}
         *
         * Foo.prototype === 空对象
         *
         * 空对象.constructor 指向 Foo函数
         *
         * 空对象.__proto__ ===Object.prototype
         *
         * Object是函数 Object.__proto__===Function.prototype
         *
         * Function.prototype.__proto__=== Object.prototype
         *
         * Function.__proto__===Function.prototype
         */

        // function fun() {
        //     var a = { name: "dd" }
        //     function fun1() {
        //         console.log(a)
        //     }
        //     fun1()
        // }
        // fun()

        // var scope = "global scope";
        // function checkscope() {
        //     var scope = "local scope";
        //     function f() {
        //         return scope;
        //     }
        //     return f;
        // }
        // checkscope()();
        /**
         * 执行全局代码 生成全局执行上下文 添加到执行上下文栈 Stick[globalContext]
         * 初始化上下文
         * global.VO{ VO:global.VO,Scope:global.VO,this:global.VO }
         * 初始化的同时把函数的作用域添加到函数 fun.[[scopes]]=global.VO
         * 执行函数 创建函数执行上下文 添加到 执行上下文栈 Stick[funContext，globalContext]
         * 初始化函数上下文 并且把函数上下文添加到作用域
         * {
         * arguments:{},
         * this
         * [scope]:[fun.AO,global.VO]
         * }
         * 执行函数 赋值给变量
         *
         */

        // 原型链继承 缺点多个实例对饮用类型的更改有问题

        // function FatherOne() {
        //     this.fatherName = "FatherOne"
        //     this.name = "FatherOne"
        //     this.arr = []
        // }
        // FatherOne.prototype.sayName = function () {
        //     console.log(this.name, this.fatherName, this.childName, this)
        //     console.log(this.arr)
        // }
        // FatherOne.prototype.pushColor = function (color) {
        //     this.arr.push(color)
        // }
        // function ChildOne() {
        //     this.name = "ChildOne"
        //     this.childName = "ChildOne"
        // }
        // ChildOne.prototype = new FatherOne()
        // const childOne = new ChildOne()
        // const childTwo = new ChildOne()
        // // childOne?.sayName()
        // childOne.pushColor("black")
        // childTwo.pushColor("green")
        // childOne.sayName()
        // childTwo.sayName()

        // 借用构造函数继承 没办法复用原型联上的方法
        // function FatherTwo() {
        //     this.name = "fatherTwo"
        //     this.age = "19"
        // }
        // function ChildTwo() {
        //     this.ctiy = "sh"
        //     FatherTwo.call(this)
        // }
        // const child2 = new ChildTwo()
        // // console.log(child2)

        // // 组合继承
        // function FatherThree(name) {
        //     this.name = name
        //     this.age = "90"
        // }
        // FatherThree.prototype.sayName = function () {
        //     return this.name
        // }
        // function ChildThree(name) {
        //     FatherThree.call(this, name)
        // }
        // // ChildThree.prototype = new FatherThree()
        // function TempF() { }
        // TempF.prototype = FatherThree.prototype
        // ChildThree.prototype = TempF()
        // ChildThree.prototype.constructor = ChildThree // 不修正就无法找到 ChildThree 函数



        // setTimeout(() => {
        //     console.log("1111")
        // }, 10000);
        // setTimeout(() => {
        //     console.log("2222")
        // }, 5000);

        // console.log("alert 之前")
        // alert("------")
        // console.log("alert 之后")
        // function Person1() {
        //     this.name = 'name'
        // }
        // Person1.prototype.sayName = function () {
        //     console.log(this.name)
        // }
        // Person1.prototype.sayName1 = () => {
        //     console.log(this)
        //     console.log(this.name)
        // }
        // const p2 = new Person1()
        // console.log(p2)
        // p2.sayName()
        // p2.sayName1()

        // class Person {
        //     static age = 18 // js 只有 static修饰符 ts有其他修饰符
        //     constructor(name) {
        //         this.name = name || "name"
        //     }
        //     sayName() {
        //         // 放在原形对象上
        //         console.log(this.name)
        //     }
        // }
        // class Student extends Person { //继承如果不自己添加构造器则直接使用父类构造器
        //     name = "stud"
        //     sayHi() {
        //         console.log(this)
        //     }
        //     sayName() {
        //         // 放在原形对象上
        //         console.log(this.name)
        //     }
        //     student = () => { }
        // }
        // const p1 = new Person()
        // p1.sayName()


        // console.log(p1)
        // const st1 = new Student('小吃')
        // console.log(st1)
        // st1.sayName();
        // st1.sayHi()

        // const statusStr = {
        //     pd: 'pending',
        //     fd: 'fulfilled',
        //     rd: 'rejected'
        // }
        // function callbackRun(arr = [], props) {
        //     while (arr.length > 0) {
        //         arr.shift()(props)
        //     }
        // }
        // class PromiseA {
        //     status = statusStr.pd
        //     resolveData
        //     rejectData
        //     fulfilledCBArr = []
        //     rejectedCBArr = []
        //     constructor(callback) {
        //         callback && callback(this.resolve, this.reject)
        //     }
        //     resolve = (resolveData) => {
        //         if (this.status === statusStr.pd) {
        //             this.status = statusStr.fd
        //             this.resolveData = resolveData
        //             callbackRun(this.fulfilledCBArr, this.resolveData)
        //         }
        //     }
        //     reject = (rejectData) => {
        //         if (this.status === statusStr.pd) {
        //             this.status = statusStr.rd
        //             this.rejectData = rejectData
        //             callbackRun(this.rejectedCBArr, this.rejectData)
        //         }
        //     }
        //     then = (onFulfilled, onRejected) => {
        //         onFulfilled && this.fulfilledCBArr.push(onFulfilled)
        //         onRejected && this.rejectedCBArr.push(onRejected)
        //     }
        // }
        // const promise = new PromiseA((resolve, reject) => {
        //     setTimeout(() => {
        //         resolve("执行")
        //     }, 1000);
        // })
        // console.log('promise',promise)
        // promise.then((res) => {
        //     console.log('11', res)
        // })
        // promise.then((res) => {
        //     console.log('22', res)
        // })
        // class PromiseB {
        //     status = statusStr.pd
        //     resolveData
        //     rejectData
        //     fulfilledCBArr = []
        //     rejectedCBArr = []
        //     constructor(callback) {
        //         callback && callback(this.resolve, this.reject)
        //     }
        //     resolve(resolveData) {
        //         if (this.status === statusStr.pd) {
        //             this.status = statusStr.fd
        //             this.resolveData = resolveData
        //             callbackRun(this.fulfilledCBArr, this.resolveData)
        //         }
        //     }
        //     reject(rejectData) {
        //         if (this.status === statusStr.pd) {
        //             this.status = statusStr.rd
        //             this.rejectData = rejectData
        //             callbackRun(this.rejectedCBArr, this.rejectData)
        //         }
        //     }
        //     then(onFulfilled, onRejected) {
        //         onFulfilled && this.fulfilledCBArr.push(onFulfilled)
        //         onRejected && this.rejectedCBArr.push(onRejected)
        //     }
        // }
        // const promise2 = new PromiseB((resolve, reject) => {
        //     setTimeout(() => {
        //         resolve("执行") // const resolve=promise2.resolve;resolve();
        //     }, 1000);
        // })

        // promise2.then((res) => {
        //     console.log('11', res)
        // })
        // console.log('promise2', promise2)

        // Promise.resolve().then(() => {
        //     console.log(0);
        //     return Promise.resolve(4);
        // }).then((res) => {
        //     console.log(res)
        // })

        // Promise.resolve().then(() => {
        //     console.log(1);
        // }).then(() => {
        //     console.log(2);
        // }).then(() => {
        //     console.log(3);
        // }).then(() => {
        //     console.log(5);
        // }).then(() => {
        //     console.log(6);
        // })

        const p1 = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve("p1 resolve")
            }, 1000);
        })
        const p2 = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve("p2 resolve")
            }, 2000);
        })
        const p3 = new Promise((resolve, reject) => {
            setTimeout(() => {
                reject("p3 resolve")
            }, 3000);
        })
        Promise.all([p1, p2, p3]).then((res) => {
            console.log("all resolve", res)
        }, (res) => {
            console.log("all reject", res)
        })
        Promise.any([p1, p2, p3]).then((res) => {
            console.log("any resolve", res)
        }, (res) => {
            console.log("any reject", res)
        })
        Promise.allSettled([p1, p2, p3]).then((res) => {
            console.log("any resolve", res)
        }, (res) => {
            console.log("any reject", res)
        })
    </script>
</body>

</html>